<<<<<<< HEAD
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time)  %>%
na.omit() %>%
group_by(Time) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate])
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M")) %>%
select(-W9_Streamflow_mm_hr)
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time)  %>%
group_by(Time) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate])
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M")) %>%
select(-W9_Streamflow_mm_hr)
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time)  %>%
na.omit() %>%
group_by(Time) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate])
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
time_to_reach_peak_rate = Time[max_rate]-Time[min_rate])
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M")) %>%
select(-W9_Streamflow_mm_hr)
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
time_to_reach_peak_rate = Time_in_hr[max_rate]-Time_in_hr[min_rate])
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time)  %>%
mutate(Time = Time_in_hr) %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
time_to_reach_peak_rate = Time[max_rate]-Time[min_rate])
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
mutate(Time = Time_in_hr) %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
time_to_reach_peak_rate = Time[max_rate]-Time[min_rate])
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M")) %>%
select(-W9_Streamflow_mm_hr)
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
time_to_reach_peak_rate = datetime_EST2[max_rate]- datetime_EST2[min_rate])
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M")) %>%
select(-W9_Streamflow_mm_hr)
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate])
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
lowest_time = datetime_EST2[min_rate],
time_to_reach_peak_rate = peak_time-lowest_time)
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record i
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
lowest_time = datetime_EST2[min_rate])
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate])
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
peak0_time = datetime_EST2[min_rate])
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
#2.0 ---- Create summary statistics for each event
#use tidy R piping and dplyr::group_by and summarize functions
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
peak0_time = datetime_EST2[min_rate])
##1.2 Assign event numbers/filter ppt time series based on event intervals ----
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M")) %>%
select(-W9_Streamflow_mm_hr)
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
#2.0 ---- Create summary statistics for each event
#use tidy R piping and dplyr::group_by and summarize functions
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
peak0_time = datetime_EST2[min_rate])
na.omit()
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
#2.0 ---- Create summary statistics for each event
#use tidy R piping and dplyr::group_by and summarize functions
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
lowest_time = datetime_EST2[min_rate],
time_to_reach_peak_rate = peak_time-lowest_time)
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
#2.0 ---- Create summary statistics for each event
#use tidy R piping and dplyr::group_by and summarize functions
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
lowest_time = datetime_EST2[min_rate],
time_to_reach_peak_rate = peak_time-lowest_time)   %>%
na.omit()
=======
>>>>>>> de997ef5af9f844dcaf9e89e04b45a0114ee8fcb
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
#2.0 ---- Create summary statistics for each event
#use tidy R piping and dplyr::group_by and summarize functions
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
lowest_time = datetime_EST2[min_rate],
time_to_reach_peak_rate = peak_time-lowest_time)
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
#2.0 ---- Create summary statistics for each event
#use tidy R piping and dplyr::group_by and summarize functions
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate],
lowest_time = datetime_EST2[min_rate],
time_to_reach_peak_rate = (peak_time-lowest_time))
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
#Now the time series record is filtered with event numbers
#2.0 ---- Create summary statistics for each event
#use tidy R piping and dplyr::group_by and summarize functions
options(dplyr.summarise.inform = FALSE)
ppt_events <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
<<<<<<< HEAD
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate])
=======
min_rate = min(Rate), max_rate = max(Rate) )
options
#clean up object list
to_remove <- ls()
rm(list(to_remove))
#clean up object list
to_remove <- ls() %>% as_tibble()
#0.0 Setup ----
library(tidyverse) #this is a set of several packages including 'readr'
library(here)
here <- here() #create a filepath object named "here" to use later
library(lubridate) #lubridate needs to be loaded separately
#1.0 Load and Clean Data ----
# adding 4 dashes "----" creates a collapsible code chunk
# specify packages using "::" in bewteen package name and function
events <- readr::read_csv(paste0(here, "/data/W9_Throughfall_Stemflow_Precipitation.csv"))
ppt <- readr::read_csv(paste0(here, "/data/W9_Streamflow_Precipitation.csv"))
#Check the format of the interval column
#"base" refers to the base R packages that come with R
base::class(events$datetime_interval_EST) #loaded as a character string
lubridate::is.interval(events$datetime_interval_EST)
##1.1 Define the interval using start and end times----
events2 <- events %>%
mutate(.after = datetime_end_GMT, #indicates where the new column is placed
datetime_interval_EST2 = lubridate::interval(start = datetime_start_GMT,
end = datetime_end_GMT,
tz = "EST"))
class(events2$datetime_interval_EST2)
tz(events2$datetime_interval_EST2) #timezone of interval gives an error
tz(events2$datetime_start_GMT) #timezone of start is UTC/GMT
view(events2) #check the new intervals match the character intervals
#To check the interval is in EST, we can pull out the start
start <- int_start(events2$datetime_interval_EST2[1])
class(start)
tz(start)
#Now you should have an set of intervals to use for filtering
intervals <- events2 %>%
distinct(datetime_interval_EST2, .keep_all = TRUE) %>%
select(Event_Number, datetime_interval_EST2)
##1.2 Assign event numbers/filter ppt time series based on event intervals ----
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M")) %>%
select(-W9_Streamflow_mm_hr)
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
View(ppt_events)
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
ppt_events2 <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate])
options(dplyr.summarise.inform = FALSE)
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
ppt_events2 <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate])
options(dplyr.summarise.inform = TRUE) #I like to see feedback
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
ppt_events2 <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)  %>%
na.omit() %>%
group_by(Time_in_hr) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate])
ppt_events2 <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(Time_in_hr2 = hour(datetime_EST2)) %>%
mutate(Rate = W9_Precipitation_mm/Time_in_hr)
View(ppt_events2)
#--- add  unique labels to 'iris' data
rownames(iris) <- paste(iris$Species, formatC(1:nrow(iris), width=3, flag="0"), sep="_")
#--- unsupervised clustering
hc <- hclust(dist(iris[, -5]))
plot(hc, hang=-1, cex=0.5)
#--- semi-supervised clustering
hc_ssuper <- hclust_semisupervised(data = iris[, -5],
groups = split(rownames(iris), iris$Species))
install.packages("RTNsurvival")
library(RTNsurvival)
install.packages("RTNsurvival")
install.packages("Bioconductor")
View(ppt_events)
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
ppt_events2 <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600) %>%
mutate(hr = lead(datetime_EST2) - datetime_EST2) %>%
mutate(Rate = W9_Precipitation_mm/hr)  %>%
na.omit() %>%
group_by(event_n) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate])
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
ppt_events2 <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600,
hr = hour(lead(datetime_EST2) - datetime_EST2),
Rate = W9_Precipitation_mm/hr)  %>%
na.omit() %>%
group_by(event_n) %>%
summarise(Total_ppt = sum(W9_Precipitation_mm),
min_ppt = min(W9_Precipitation_mm), max_ppt = max(W9_Precipitation_mm),
min_rate = min(Rate), max_rate = max(Rate), peak_time = datetime_EST2[max_rate])
View(ppt_events2)
#0.0 Setup ----
library(tidyverse) #this is a set of several packages including 'readr'
library(here)
here <- here() #create a filepath object named "here" to use later
library(lubridate) #lubridate needs to be loaded separately
#1.0 Load and Clean Data ----
# adding 4 dashes "----" creates a collapsible code chunk
# specify packages using "::" in bewteen package name and function
events <- readr::read_csv(paste0(here, "/data/W9_Throughfall_Stemflow_Precipitation.csv"))
ppt <- readr::read_csv(paste0(here, "/data/W9_Streamflow_Precipitation.csv"))
#use dplyr::glimpse to browse data
glimpse(events)
glimpse(ppt)
#identifying class
sapply(events, class)
sapply(ppt, class)
#Check the format of the interval column
#"base" refers to the base R packages that come with R
base::class(events$datetime_interval_EST) #loaded as a character string
lubridate::is.interval(events$datetime_interval_EST)
##1.1 Define the interval using start and end times----
events2 <- events %>%
mutate(.after = datetime_end_GMT, #indicates where the new column is placed
datetime_interval_EST2 = lubridate::interval(start = datetime_start_GMT,
end = datetime_end_GMT,
tz = "EST"))
class(events2$datetime_interval_EST2)
tz(events2$datetime_interval_EST2) #timezone of interval gives an error
tz(events2$datetime_start_GMT) #timezone of start is UTC/GMT
view(events2) #check the new intervals match the character intervals
#To check the interval is in EST, we can pull out the start
start <- int_start(events2$datetime_interval_EST2[1])
class(start)
tz(start)
#Now you should have an set of intervals to use for filtering
intervals <- events2 %>%
distinct(datetime_interval_EST2, .keep_all = TRUE) %>%
select(Event_Number, datetime_interval_EST2)
View(intervals)
##1.2 Assign event numbers/filter ppt time series based on event intervals ----
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M")) %>%
select(-W9_Streamflow_mm_hr)
View(ppt2)
##1.2 Assign event numbers/filter ppt time series based on event intervals ----
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M"),
minute = minute(datetime_EST2)) %>%
select(-W9_Streamflow_mm_hr)
View(ppt2)
##1.2 Assign event numbers/filter ppt time series based on event intervals ----
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M")) %>%
filter(minute(datetime_EST2) == 0) %>%
select(-W9_Streamflow_mm_hr)
View(ppt2)
##1.2 Assign event numbers/filter ppt time series based on event intervals ----
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M")) %>%
filter(minute(datetime_EST2) == 0) %>% #remove subhourly timestamps
select(-W9_Streamflow_mm_hr) %>%
arrange(datetime_EST2)
View(ppt2)
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
View(ppt_events)
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
options(dplyr.summarise.inform = TRUE) #I like to see the feedback
#Now you should have an set of intervals to use for filtering
intervals <- events2 %>%
distinct(datetime_interval_EST2, .keep_all = TRUE) %>%
select(Event_Number, datetime_interval_EST2) %>%
mutate(event_dur_sec = dseconds(datetime_interval_EST2))
View(intervals)
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
ppt_events2 <- ppt_events %>%
mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600,
hr = hour(lead(datetime_EST2) - datetime_EST2),
Rate = W9_Precipitation_mm/hr)  %>%
na.omit() %>%
group_by(event_n) %>%
dplyr::summarise(P_event_mm = sum(W9_Precipitation_mm),
P_max_event_mm_hr = max(W9_Precipitation_mm, na.rm = TRUE),
P_mean_event_mm_hr = mean(W9_Precipitation_mm, na.rm = TRUE))
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
ppt_events2 <- ppt_events %>%
# mutate(Time_in_hr = hour(datetime_EST2) + minute(datetime_EST2)/60 + second(datetime_EST2)/3600,
#        hr = hour(lead(datetime_EST2) - datetime_EST2),
#        Rate = W9_Precipitation_mm/hr)  %>%
# na.omit() %>%
group_by(event_n) %>%
dplyr::summarise(P_event_mm = sum(W9_Precipitation_mm),
P_max_event_mm_hr = max(W9_Precipitation_mm, na.rm = TRUE),
P_mean_event_mm_hr = mean(W9_Precipitation_mm, na.rm = TRUE))
View(ppt_events2)
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
ppt_events2 <- ppt_events %>%
group_by(event_n) %>%
dplyr::summarise(P_event_mm = sum(W9_Precipitation_mm),
P_max_event_mm_hr = max(W9_Precipitation_mm, na.rm = TRUE),
P_mean_event_mm_hr = mean(W9_Precipitation_mm, na.rm = TRUE))%>%
left_join(ppt_events, ., by = "event_n")
View(ppt_events2)
View(events2)
View(intervals)
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
ppt_events2 <- ppt_events %>%
group_by(event_n) %>%
dplyr::summarise(P_event_mm = sum(W9_Precipitation_mm),
P_max_event_mm_hr = max(W9_Precipitation_mm, na.rm = TRUE),
P_mean_event_mm_hr = mean(W9_Precipitation_mm, na.rm = TRUE))%>%
left_join(intervals2, ., by = "event_n")
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
ppt_events2 <- ppt_events %>%
group_by(event_n) %>%
dplyr::summarise(P_event_mm = sum(W9_Precipitation_mm),
P_max_event_mm_hr = max(W9_Precipitation_mm, na.rm = TRUE),
P_mean_event_mm_hr = mean(W9_Precipitation_mm, na.rm = TRUE))%>%
left_join(intervals, ., by = "event_n")
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
events_summary <- ppt_events %>%
group_by(event_n) %>%
dplyr::summarise(P_event_mm = sum(W9_Precipitation_mm),
P_max_event_mm_hr = max(W9_Precipitation_mm, na.rm = TRUE),
P_mean_event_mm_hr = mean(W9_Precipitation_mm, na.rm = TRUE))%>%
left_join(intervals, ., by = "Event_Number")
#Now you should have an set of intervals to use for filtering
intervals <- events2 %>%
distinct(datetime_interval_EST2, .keep_all = TRUE) %>%
select(event_n, datetime_interval_EST2) %>%
mutate(event_dur_sec = dseconds(datetime_interval_EST2))
#1.0 Load and Clean Data ----
# adding 4 dashes "----" creates a collapsible code chunk
# specify packages using "::" in bewteen package name and function
events <- readr::read_csv(paste0(here, "/data/W9_Throughfall_Stemflow_Precipitation.csv"))
ppt <- readr::read_csv(paste0(here, "/data/W9_Streamflow_Precipitation.csv"))
#use dplyr::glimpse to browse data
glimpse(events)
glimpse(ppt)
#identifying class
sapply(events, class)
sapply(ppt, class)
#Check the format of the interval column
#"base" refers to the base R packages that come with R
base::class(events$datetime_interval_EST) #loaded as a character string
lubridate::is.interval(events$datetime_interval_EST)
##1.1 Define the interval using start and end times----
events2 <- events %>%
mutate(.after = datetime_end_GMT, #indicates where the new column is placed
datetime_interval_EST2 = lubridate::interval(start = datetime_start_GMT,
end = datetime_end_GMT,
tz = "EST"))
class(events2$datetime_interval_EST2)
tz(events2$datetime_interval_EST2) #timezone of interval gives an error
tz(events2$datetime_start_GMT) #timezone of start is UTC/GMT
#To check the interval is in EST, we can pull out the start
start <- int_start(events2$datetime_interval_EST2[1])
class(start)
tz(start)
#Now you should have an set of intervals to use for filtering
intervals <- events2 %>%
distinct(datetime_interval_EST2, .keep_all = TRUE) %>%
select(Event_Number, datetime_interval_EST2) %>%
mutate(event_dur_sec = dseconds(datetime_interval_EST2))
##1.2 Assign event numbers/filter ppt time series based on event intervals ----
ppt2 <- ppt %>%
mutate(.after = datetime_EST, #indicates where the new column is placed
datetime_EST2 = as.POSIXct(datetime_EST, format = "%m/%d/%Y %H:%M")) %>%
filter(minute(datetime_EST2) == 0) %>% #remove subhourly timestamps
select(-W9_Streamflow_mm_hr) %>%
arrange(datetime_EST2) #Order from earliest to latest timestamp
#create an empty dataframe with same headers
ppt_events <- slice(ppt2, 0)
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(event_n = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
i=1
rm(i)
for (i in 1:length(intervals$Event_Number)) {
interval <- ppt2 %>%
filter(datetime_EST2 %within% intervals$datetime_interval_EST2[i]) %>%
mutate(Event_Number = intervals$Event_Number[i])
ppt_events <- bind_rows(ppt_events, interval)
}
#Check and correct timezone
tz(ppt_events$datetime_EST2)
attr(ppt_events$datetime_EST2, "tzone") <- "EST"
tz(ppt_events$datetime_EST2)
options(dplyr.summarise.inform = TRUE) #I like to see the feedback
#I try to avoid overwriting objects with the same name
#It helps with troubleshooting and you can always remove old objects
events_summary <- ppt_events %>%
group_by(Event_Number) %>%
dplyr::summarise(P_event_mm = sum(W9_Precipitation_mm),
P_max_event_mm_hr = max(W9_Precipitation_mm, na.rm = TRUE),
P_mean_event_mm_hr = mean(W9_Precipitation_mm, na.rm = TRUE))%>%
left_join(intervals, ., by = "Event_Number")
View(events_summary)
#clean up object list
to_remove <- ls() %>% as_tibble()
rm(list(to_remove))
to_remove <- ls()
rm(list(to_remove))
rm(to_remove)
rm(ls())
>>>>>>> de997ef5af9f844dcaf9e89e04b45a0114ee8fcb
